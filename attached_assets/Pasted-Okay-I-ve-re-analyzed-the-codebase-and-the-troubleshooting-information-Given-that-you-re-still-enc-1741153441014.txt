Okay, I've re-analyzed the codebase and the troubleshooting information. Given that you're still encountering authentication-related issues (401 errors) after implementing previous suggestions, let's focus on these areas and then check how the AI and db integrations are looking:

I. Client-Side Authentication Context:

client/src/hooks/use-auth.tsx:

Session Check: The useEffect to check initial session:

useEffect(() => {
  let mounted = true;

  const checkSession = async () => {
    try {
      const { data: { session }, error } = await supabase.auth.getSession();

      if (!mounted) return;

      if (error) { // Check for errors when fetching session
        console.error('Error fetching session:', error);
        return;  // Exit early if there is a session retrieval problem
      }

      if (session?.user) {
        setUser(session.user);
      } else {
        setUser(null);
      }
    } finally {
      if (mounted) setIsLoading(false);
    }
  };
content_copy
download
Use code with caution.
TypeScript

Token retrieval test:
The most likely problem is an issue related to when the localStorage is set for the token, and how it's been used in components/client code.
Check your API to confirm this

Refactor the ProtectedRoute to account for these different authentication state
* Add another statement within ProtectedRoute to handle the re-authentication process.

//Inside ProtectedRoute component:
const { user, isLoading } = useAuth();

if(error){
    console.error("Authentication context error:", error.message)
     return (
      <Route path={path}>
        <Redirect to="/auth" />
      </Route>
    );
}

  if (isLoading) {
    return (
      <Route path={path}>
        <div className="flex items-center justify-center min-h-screen">
          <Loader2 className="h-8 w-8 animate-spin text-border" />
        </div>
      </Route>
    );
  }
content_copy
download
Use code with caution.
TypeScript

The purpose of this change is to verify that the access_token is being sent as expected with a valid session, and to see if the auth headers are even being added.

**Examine Auth middleware and set cookies for your application
* Add your custom cookie logic to set the httponly and secure cookies, and read those and refresh them in the next steps.

res.cookie('access_token', data.session.access_token, { httpOnly: true, secure: true, path: '/', sameSite: 'strict' });
content_copy
download
Use code with caution.
TypeScript

Step 3: Double check User Persistance & Session
There may be a disconnect that could be a result of supabase attempting to refresh sessions (as it appears to be set up for). Since the session persistence requires a cookie and localstore it may be incorrectly configured.

Test the settings configurations.

4. Review API Request Logging:

Refine the apiRequest function to output the current token:

//client/src/lib/queryClient.ts
export async function apiRequest(
  method: string,
  url: string,
  data?: unknown | undefined,
): Promise<Response> {
  try {
    const token = await getAuthToken();
    console.log('Making API request with token: ', token ? 'yes' : 'no', 'token=', token);

    const res = await fetch(url, {
      method,
      headers: {
        ...(data ? { "Content-Type": "application/json" } : {}),
        "Authorization": `Bearer ${token}`,
      },
      body: data ? JSON.stringify(data) : undefined,
      credentials: "include",
    });
content_copy
download
Use code with caution.
TypeScript

5. Code Clean Up - remove deprecated configurations

Remove Drizzle Configuration: Double-check every area that is referencing to drizzle, and remove them, to avoid future issues

Remove db.ts in the server, and other unused configuration files

If you are experiencing database or schema issues, you can try to clear cache and prune your supabase db to clear any unnessary things.
I hope that helps. If your application is still acting up, let me know. We can debug more thoroughly from there!